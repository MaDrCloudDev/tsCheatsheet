# Classes

## Member Types

```ts copy
class Pet {
	name: string; // property
}

const pet = new Pet();
pet.name = 'Mittens';
```

## Member Visibility

Member properties can be public, private, or protected.

- Public members are accessible from anywhere (default).
- Private members are only accessible from within the class.
- Protected members are accessible from within the class and from classes that extend from the class.

```ts copy
class Pet2 {
	private name: string;

	public constructor(name: string) {
		this.name = name;
	}

	public getName(): string {
		return this.name;
	}
}

const pet2 = new Pet2('Snuggles');
console.log(pet2.getName()); // person.name isn't accessible
// from outside the class since it's private
```

## Parameter Properties

In TypeScript, you can conveniently define class members in the constructor by adding visibility modifiers to the constructor parameters. This allows you to automatically create and initialize class properties with a concise syntax.

```ts copy
class Pet3 {
	// name is a private member variable
	public constructor(private name: string) {}

	public getName(): string {
		return this.name;
	}
}

const pet3 = new Pet3('Snowball');
console.log(pet3.getName()); // logs 'Snowball'
```

## Readonly

```ts copy
class Pet4 {
	private readonly name: string;

	public constructor(name: string) {
		// name cannot be changed after this first definition,
		// which must be at it's declaration or in the constructor.
		this.name = name;
	}

	public getName(): string {
		return this.name;
	}
}

const pet4 = new Pet4('Jingles');
console.log(pet4.getName());
```

## Inheritance - implements

The implements key word is used to indicate that a class implements an interface to define the type a class must conform to.

```ts copy
interface Shape {
	getArea: () => number;
}

class Rectangle implements Shape {
	public constructor(
		protected readonly width: number,
		protected readonly height: number
	) {}

	public getArea(): number {
		return this.width * this.height;
	}
}
```

## Inheritance - extends (extends Rectangle above)

A class can extend another class to inherit its members. A class can only extend one other class.

```ts copy
interface Shape {
	getArea: () => number;
}

class Square extends Rectangle {
	public constructor(width: number) {
		super(width, width);
	} // getArea gets inherited from Rectangle
}
```

## Override

When you use a class to extend another, you can override methods from the parent class by redefining them in the child class. You can also override properties.

```ts copy
interface Shape {
	getArea: () => number;
}

class Rectangle2 implements Shape {
	// using protected for these members allows access from
	// classes that extend from this class, such as Square
	public constructor(
		protected readonly width: number,
		protected readonly height: number
	) {}

	public getArea(): number {
		return this.width * this.height;
	}

	public toString(): string {
		return `Rectangle[width=${this.width}, height=${this.height}]`;
	}
}

class Square2 extends Rectangle2 {
	public constructor(width: number) {
		super(width, width);
	} // this toString replaces the toString from Rectangle

	public override toString(): string {
		return `Square[width=${this.width}]`;
	}
}
```

## Abstract Classes

Can be used as a base for other classes, without having to implement or use all that classes members.

```ts copy
abstract class Polygon {
	public abstract getArea(): number;

	public toString(): string {
		return `Polygon[area=${this.getArea()}]`;
	}
}

class Rectangle3 extends Polygon {
	public constructor(
		protected readonly width: number,
		protected readonly height: number
	) {
		super();
	}

	public getArea(): number {
		return this.width * this.height;
	}
}
```

---
