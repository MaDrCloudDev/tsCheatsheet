{"/arrays":{"title":"Arrays","data":{"":"","arrays#Arrays":"const names: string[] = [];\nnames.push('Matt'); // no error\n// names.push(3); // Error: Argument of type 'number'\n// is not assignable to parameter of type 'string'.","readonly#Readonly":"const names: readonly string[] = ['Matt'];\nnames.push('Michael'); // Error: Property 'push' does\n// not exist on type 'readonly string[]'.","type-inference#Type Inference":"const numbers = [1, 2, 3]; // inferred to type number[]\nnumbers.push(4); // no error\nnumbers.push('4'); // Error: Argument of type 'string' is\n// not assignable to parameter of type 'number'.\nlet head: number = numbers[0]; // no error"}},"/casting":{"title":"Casting","data":{"":"","casting-types#Casting Types":"let a: unknown = 'Hello World!';\nconsole.log((a as string).length);\n\n// Casting doesn't really change type, it just tells\n// the compiler to treat it as a different type\nlet a2: unknown = 3;\nconsole.log((a2 as string).length); // logs undefined\n// because numbers don't have a length","typescript-typechecks-casts#TypeScript typechecks casts":"console.log((3 as string).length); // Error: Conversion\n// of type 'number' to type 'string' may be a mistake\n// because neither type sufficiently overlaps with the\n// other. If this was intentional, convert the expression\n// to 'unknown' first.","casting-using--doesnt-work-in-tsx#Casting using <>; doesn't work in TSX":"let a3: unknown = 'Hello World!';\nconsole.log((<string>a).length);","forced-casting#Forced casting":"let a4 = 'Hello World!';\nconsole.log((a4 as unknown as number).length); // a is not\n// actually a number so returns undefined"}},"/classes":{"title":"Classes","data":{"":"","member-types#Member Types":"class Pet {\nname: string;\n}\n\nconst pet = new Pet();\npet.name = 'Buttons';","member-visibility#Member Visibility":"class Pet2 {\nprivate name: string;\n\npublic constructor(name: string) {\nthis.name = name;\n}\n\npublic getName(): string {\nreturn this.name;\n}\n}\n\nconst pet2 = new Pet2('Snuggles');\nconsole.log(pet2.getName()); // person.name isn't accessible from outside the class since it's private","parameter-properties#Parameter Properties":"class Pet3 {\n// name is a private member variable\npublic constructor(private name: string) {}\n\npublic getName(): string {\nreturn this.name;\n}\n}\n\nconst pet3 = new Pet3('Snowball');\nconsole.log(pet3.getName());","readonly#Readonly":"class Pet4 {\nprivate readonly name: string;\n\npublic constructor(name: string) {\n// name cannot be changed after this first definition, which must be at it's declaration or in the constructor.\nthis.name = name;\n}\n\npublic getName(): string {\nreturn this.name;\n}\n}\n\nconst pet4 = new Pet4('Jingles');\nconsole.log(pet4.getName());","inheritance---implements#Inheritance - implements":"interface Shape {\ngetArea: () => number;\n}\n\nclass Rectangle implements Shape {\npublic constructor(\nprotected readonly width: number,\nprotected readonly height: number\n) {}\n\npublic getArea(): number {\nreturn this.width * this.height;\n}\n}","inheritance---extends-extends-rectangle-above#Inheritance - extends (extends Rectangle above)":"interface Shape {\ngetArea: () => number;\n}\n\nclass Square extends Rectangle {\npublic constructor(width: number) {\nsuper(width, width);\n} // getArea gets inherited from Rectangle\n}","override#Override":"interface Shape {\ngetArea: () => number;\n}\n\nclass Rectangle2 implements Shape {\n// using protected for these members allows access from classes that extend from this class, such as Square\npublic constructor(\nprotected readonly width: number,\nprotected readonly height: number\n) {}\n\npublic getArea(): number {\nreturn this.width * this.height;\n}\n\npublic toString(): string {\nreturn `Rectangle[width=${this.width}, height=${this.height}]`;\n}\n}\n\nclass Square2 extends Rectangle2 {\npublic constructor(width: number) {\nsuper(width, width);\n} // this toString replaces the toString from Rectangle\n\npublic override toString(): string {\nreturn `Square[width=${this.width}]`;\n}\n}","abstract-classes#Abstract Classes":"abstract class Polygon {\npublic abstract getArea(): number;\n\npublic toString(): string {\nreturn `Polygon[area=${this.getArea()}]`;\n}\n}\n\nclass Rectangle3 extends Polygon {\npublic constructor(\nprotected readonly width: number,\nprotected readonly height: number\n) {\nsuper();\n}\n\npublic getArea(): number {\nreturn this.width * this.height;\n}\n}"}},"/":{"title":"Introduction","data":{"":"Welcome."}},"/objectTypes":{"title":"Object types","data":{"":"const car: { maker: string; model: string; year: number } = {\nmaker: 'Honda',\nmodel: 'Civic',\nyear: 2008,\n};","infered-type#Infered Type":"Type inferred from type used above.\ncar.maker = 'Ford'; // no error\ncar.maker = 2; // Error: Type 'number' is not assignable\n// to type 'string'.","without-optional-properties#Without Optional Properties":"const vehicle: { maker: string; mileage: number } = {\n// Error: Property 'mileage' is missing in type\n// '{ type: string; }' but required in type\n// '{ maker: string; mileage: number; }'.\nmaker: 'Honda',\n};\nvehicle.mileage = 3000;\n// with optional properties\nconst vehicle2: { maker: string; mileage?: number } = {\n// no error\nmaker: 'Honda',\n};\nvehicle2.mileage = 3000;","index-signatures#Index Signatures":"const ageNameMap: { [index: string]: number } = {};\nageNameMap.Matt = 25; // no error\nageNameMap.Michael = 'Fifty'; // Error: Type 'string' is not\n// assignable to type 'number'."}},"/tuples":{"title":"Tuples: Typed Arrays","data":{"":"","define-tuple#Define Tuple":"let aTuple: [number, boolean, string];\n\n// initialize correctly\naTuple = [3, true, 'Hello World!'];\n\n// initialize incorrectly; throws an error\n// aTuple = [true, 'Hello Wold!', 3];","readonly-tuple#Readonly Tuple":"// We have no type safety in our tuple for indexes 3+\naTuple.push('added after initialization');\nconsole.log(aTuple);\n\n// define readonly tuple\nconst aReadonlyTuple: readonly [number, boolean, string] = [\n3,\ntrue,\n'Hello World!',\n];\n// throws error as it is readonly.\naReadonlyTuple.push('added after initialization');","named-tuples#Named Tuples":"const graph: [x: number, y: number] = [51.0, 49.0];","destructuring-tuples#Destructuring Tuples":"const graph2: [number, number] = [51.0, 49.0];\nconst [x, y] = graph;"}},"/types":{"title":"Types","data":{"":"","explicit#Explicit":"let firstName: string = 'Matt';","implicit#Implicit":"let firstName = 'Matt';","any#Any":"let x = true;\nx = 'string'; // Error: Type 'string' is not assignable\n// to type 'boolean'.\nMath.round(x); // Error: Argument of type 'boolean' is\n// not assignable to parameter of type 'number'.\n\nlet y: any = true;\ny = 'string'; // no error; can be \"any\" type\nMath.round(y); // no error; can be \"any\" type","unknown#Unknown":"let z: unknown = 1;\nz = 'string'; // no error\nz = {\nrunANonExistentMethod: () => {\nconsole.log('I am running a non existent method');\n},\n} as { runANonExistentMethod: () => void };\n// In the absence of type information, what measures can\n// we take to prevent the occurrence of the error in the\n// code snippet that has been commented out?\n// z.runANonExistentMethod(); // Error: Object is of type\n// 'unknown'.\nif (typeof z === 'object' && z !== null) {\n(z as { runANonExistentMethod: Function }).runANonExistentMethod();\n}\n// We cast multiple times, we can check in the if() if our\n// type is secure and have a safer casting.","never#Never":"let a: never = true; // Error: Type 'boolean' is not\n// assignable to type 'never'.","null--undefined#Null & Undefined":"let b: undefined = undefined;\nlet c: null = null;"}}}