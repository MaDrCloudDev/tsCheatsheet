{"/arrays":{"title":"Arrays","data":{"":"","arrays#Arrays":"const names: string[] = [];\nnames.push('Matt'); // no error\n// names.push(3); // Error: Argument of type 'number'\n// is not assignable to parameter of type 'string'.","readonly#Readonly":"const names: readonly string[] = ['Matt'];\nnames.push('Michael'); // Error: Property 'push' does\n// not exist on type 'readonly string[]'.","type-inference#Type Inference":"const numbers = [1, 2, 3]; // inferred to type number[]\nnumbers.push(4); // no error\nnumbers.push('4'); // Error: Argument of type 'string' is\n// not assignable to parameter of type 'number'.\nlet head: number = numbers[0]; // no error"}},"/":{"title":"Introduction","data":{"":"Welcome."}},"/objectTypes":{"title":"Object types","data":{"":"const car: { maker: string; model: string; year: number } = {\nmaker: 'Honda',\nmodel: 'Civic',\nyear: 2008,\n};","infered-type#Infered Type":"Type inferred from type used above.\ncar.maker = 'Ford'; // no error\ncar.maker = 2; // Error: Type 'number' is not assignable\n// to type 'string'.","without-optional-properties#Without Optional Properties":"const vehicle: { maker: string; mileage: number } = {\n// Error: Property 'mileage' is missing in type\n// '{ type: string; }' but required in type\n// '{ maker: string; mileage: number; }'.\nmaker: 'Honda',\n};\nvehicle.mileage = 3000;\n// with optional properties\nconst vehicle2: { maker: string; mileage?: number } = {\n// no error\nmaker: 'Honda',\n};\nvehicle2.mileage = 3000;","index-signatures#Index Signatures":"const ageNameMap: { [index: string]: number } = {};\nageNameMap.Matt = 25; // no error\nageNameMap.Michael = 'Fifty'; // Error: Type 'string' is not\n// assignable to type 'number'."}},"/tuples":{"title":"Tuples: Typed Arrays","data":{"":"","define-tuple#Define Tuple":"let aTuple: [number, boolean, string];\n\n// initialize correctly\naTuple = [3, true, 'Hello World!'];\n\n// initialize incorrectly; throws an error\n// aTuple = [true, 'Hello Wold!', 3];","readonly-tuple#Readonly Tuple":"// We have no type safety in our tuple for indexes 3+\naTuple.push('added after initialization');\nconsole.log(aTuple);\n\n// define readonly tuple\nconst aReadonlyTuple: readonly [number, boolean, string] = [\n3,\ntrue,\n'Hello World!',\n];\n// throws error as it is readonly.\naReadonlyTuple.push('added after initialization');","named-tuples#Named Tuples":"const graph: [x: number, y: number] = [51.0, 49.0];","destructuring-tuples#Destructuring Tuples":"const graph2: [number, number] = [51.0, 49.0];\nconst [x, y] = graph;"}},"/types":{"title":"Types","data":{"":"","explicit#Explicit":"let firstName: string = 'Matt';","implicit#Implicit":"let firstName = 'Matt';","any#Any":"let x = true;\nx = 'string'; // Error: Type 'string' is not assignable\n// to type 'boolean'.\nMath.round(x); // Error: Argument of type 'boolean' is\n// not assignable to parameter of type 'number'.\n\nlet y: any = true;\ny = 'string'; // no error; can be \"any\" type\nMath.round(y); // no error; can be \"any\" type","unknown#Unknown":"let z: unknown = 1;\nz = 'string'; // no error\nz = {\nrunANonExistentMethod: () => {\nconsole.log('I am running a non existent method');\n},\n} as { runANonExistentMethod: () => void };\n// In the absence of type information, what measures can\n// we take to prevent the occurrence of the error in the\n// code snippet that has been commented out?\n// z.runANonExistentMethod(); // Error: Object is of type\n// 'unknown'.\nif (typeof z === 'object' && z !== null) {\n(z as { runANonExistentMethod: Function }).runANonExistentMethod();\n}\n// We cast multiple times, we can check in the if() if our\n// type is secure and have a safer casting.","never#Never":"let a: never = true; // Error: Type 'boolean' is not\n// assignable to type 'never'.","null--undefined#Null & Undefined":"let b: undefined = undefined;\nlet c: null = null;"}}}